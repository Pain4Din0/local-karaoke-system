<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+SC:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/artplayer/dist/artplayer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', 'Noto Sans JP', sans-serif;
        }

        body.hide-cursor {
            cursor: none;
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }
    </style>
</head>

<body class="bg-black text-white overflow-hidden h-screen w-screen selection:bg-white selection:text-black">
    <div id="app" class="relative w-full h-full">

        <div v-if="!hasInteracted" @click="startInteraction"
            class="absolute inset-0 z-50 bg-black flex flex-col items-center justify-center cursor-pointer">
            <div class="border border-white/20 hover:bg-white/10 transition-colors rounded-full p-6 mb-4 animate-pulse">
                <i class="ri-hand-coin-line text-4xl"></i>
            </div>
            <p class="text-xs tracking-[0.2em] text-gray-500 uppercase">Click to Initialize System</p>
        </div>

        <div id="artplayer" class="w-full h-full absolute top-0 left-0 z-10"></div>

        <div v-if="!isPlayingVideo && hasInteracted"
            class="absolute inset-0 flex items-center justify-center z-20 bg-black">
            <div class="w-full max-w-5xl px-8">

                <div v-if="currentSong && currentSong.status !== 'ready'"
                    class="space-y-6 text-center max-w-2xl mx-auto">
                    <div class="flex justify-between items-end mb-2">
                        <span class="text-xs font-mono text-gray-400">DOWNLOADING</span>
                        <span class="text-xs font-mono text-white">{{ Math.floor(currentSong.progress || 0) }}%</span>
                    </div>
                    <div class="w-full h-[1px] bg-gray-800 overflow-hidden">
                        <div class="h-full bg-white transition-all duration-300 ease-out"
                            :style="{width: (currentSong.progress || 0) + '%'}"></div>
                    </div>
                    <p class="text-3xl font-light text-white truncate mt-8 opacity-80">{{ currentSong.title }}</p>
                </div>

                <div v-else class="flex flex-col md:flex-row items-center justify-center gap-12 select-none">

                    <div @click="nextNetwork" class="relative group cursor-pointer"
                        title="Click to switch network interface">
                        <div
                            class="bg-white p-4 rounded-xl shadow-2xl transition-transform group-hover:scale-105 duration-300 border-4 border-transparent group-hover:border-zinc-700">
                            <div id="qrcode" class="w-[220px] h-[220px]"></div>
                        </div>

                        <div v-if="networks.length > 1" class="absolute -bottom-10 left-0 w-full text-center">
                            <p
                                class="text-[10px] uppercase tracking-widest text-zinc-500 group-hover:text-white transition-colors bg-black/50 py-1 rounded">
                                <i class="ri-arrow-left-right-line align-middle mr-1"></i> Click QR to Switch
                            </p>
                            <div class="flex justify-center gap-1.5 mt-2">
                                <div v-for="(net, idx) in networks" :key="idx"
                                    class="w-1.5 h-1.5 rounded-full transition-all"
                                    :class="idx === currentNetIndex ? 'bg-white' : 'bg-zinc-800'"></div>
                            </div>
                        </div>
                    </div>

                    <div class="text-left space-y-8 min-w-[300px]">
                        <div>
                            <p class="text-xs text-zinc-500 font-mono tracking-widest uppercase mb-2">Current Network
                            </p>
                            <div
                                class="inline-flex items-center gap-2 border border-zinc-800 px-3 py-1 rounded-full bg-zinc-900">
                                <i class="ri-router-line text-zinc-400 text-sm"></i>
                                <span class="text-sm font-medium text-zinc-300">{{ currentNetwork.name }}</span>
                            </div>
                        </div>

                        <div>
                            <p class="text-xs text-zinc-500 font-mono tracking-widest uppercase mb-2">Connect via URL
                            </p>
                            <p class="text-3xl font-light text-white tracking-tight break-all cursor-text select-text">
                                <span class="text-zinc-600">http://</span>{{ currentNetwork.ip }}<span
                                    class="text-zinc-600">:{{ systemPort }}</span>
                            </p>
                        </div>

                        <div class="pt-4 border-t border-zinc-900">
                            <div class="flex items-center gap-2 text-zinc-500">
                                <i class="ri-wifi-line"></i>
                                <span class="text-xs uppercase tracking-wider">Host SSID: {{ systemSSID }}</span>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <Transition name="song-info">
            <div v-if="isPlayingVideo && showInfo" class="absolute top-8 left-8 max-w-2xl z-30 pointer-events-none">
                <div class="bg-black/40 backdrop-blur-md rounded-2xl p-6 border border-white/10 shadow-2xl">
                    <h1 class="text-4xl font-bold leading-tight text-white mb-3 line-clamp-2 drop-shadow-sm">{{
                        currentSong.title }}</h1>
                    <div class="flex items-center gap-3">
                        <span
                            class="bg-white/20 px-2 py-0.5 text-[10px] font-bold rounded uppercase tracking-wider text-white/90">Requested
                            By</span>
                        <span class="text-lg font-light text-gray-200">{{ currentSong.requester }}</span>
                    </div>
                </div>
            </div>
        </Transition>
    </div>

    <script>
        const { createApp, ref, computed, nextTick, watch } = Vue;
        const socket = io();
        let art = null;
        let tickInterval = null;

        createApp({
            setup() {
                const currentSong = ref(null);
                const showInfo = ref(false);
                const hasInteracted = ref(false);
                const systemInfo = ref({ ssid: 'Loading...', url: 'Loading...', ip: '' });
                const isPlayingVideo = computed(() => currentSong.value && currentSong.value.status === 'ready');

                const networks = ref([{ name: 'Loading', ip: '...' }]);
                const currentNetIndex = ref(0);
                const systemSSID = ref('...');
                const systemPort = ref('8080');

                const currentNetwork = computed(() => networks.value[currentNetIndex.value] || networks.value[0]);

                watch(isPlayingVideo, (playing) => {
                    if (playing) {
                        document.body.classList.add('hide-cursor');
                    } else {
                        document.body.classList.remove('hide-cursor');
                    }
                });

                const nextNetwork = () => {
                    if (networks.value.length <= 1) return;
                    currentNetIndex.value = (currentNetIndex.value + 1) % networks.value.length;
                    nextTick(() => generateQR());
                };

                // --- Karaoke Audio Switching (AI-based, uses pre-processed karaoke track) ---
                let karaokeAudio = null;
                let isVocalRemovalActive = false;

                const initKaraokeAudio = (karaokeSrc) => {
                    if (karaokeAudio) {
                        karaokeAudio.pause();
                        karaokeAudio = null;
                    }
                    if (!karaokeSrc) return;

                    karaokeAudio = new Audio(karaokeSrc);
                    karaokeAudio.preload = 'auto';
                    karaokeAudio.volume = art ? art.volume : 0.8;
                    karaokeAudio.muted = !isVocalRemovalActive;

                    // Wait for audio to be ready before syncing
                    karaokeAudio.addEventListener('canplaythrough', () => {
                        if (art && isVocalRemovalActive && !art.video.paused) {
                            karaokeAudio.currentTime = art.currentTime;
                            karaokeAudio.play().catch(() => { });
                        }
                    }, { once: true });

                    // Start loading
                    karaokeAudio.load();
                };

                const toggleVocalRemoval = (active) => {
                    isVocalRemovalActive = active;
                    if (art && art.video) {
                        // Swap audio sources: mute video when using karaoke, mute karaoke when using video
                        art.video.muted = active;
                        if (karaokeAudio) {
                            karaokeAudio.muted = !active;
                            if (active) {
                                // Sync time and match play state
                                karaokeAudio.currentTime = art.currentTime;
                                if (!art.video.paused) {
                                    karaokeAudio.play().catch(() => { });
                                } else {
                                    karaokeAudio.pause();
                                }
                            } else {
                                karaokeAudio.pause();
                            }
                        }
                    }
                };

                // Sync karaoke audio with video - called periodically and on events
                const syncKaraokeAudio = () => {
                    if (!karaokeAudio || !art || !art.video) return;

                    // Sync volume
                    karaokeAudio.volume = art.volume;

                    // Only sync if vocal removal is active
                    if (!isVocalRemovalActive) {
                        if (!karaokeAudio.paused) karaokeAudio.pause();
                        return;
                    }

                    // Sync time if drifted
                    if (Math.abs(karaokeAudio.currentTime - art.currentTime) > 0.2) {
                        karaokeAudio.currentTime = art.currentTime;
                    }

                    // Sync play state
                    if (!art.video.paused && karaokeAudio.paused) {
                        karaokeAudio.play().catch(() => { });
                    } else if (art.video.paused && !karaokeAudio.paused) {
                        karaokeAudio.pause();
                    }
                };

                const initAudioContext = async () => {
                    if (window.audioCtx) return;
                    try {
                        window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        await window.audioCtx.audioWorklet.addModule('pitch-processor.js');
                        window.pitchNode = new AudioWorkletNode(window.audioCtx, 'pitch-processor');
                    } catch (e) {
                        console.error("AudioContext Init Failed", e);
                    }
                };

                const connectAudioNode = () => {
                    if (!art || !window.audioCtx || !window.pitchNode || art.audioEncoded) return;

                    try {
                        const video = art.video;
                        if (video._sourceNode) return;

                        const source = window.audioCtx.createMediaElementSource(video);
                        video._sourceNode = source;

                        // Chain: Source -> PitchNode -> Destination (No DSP vocal remover)
                        source.connect(window.pitchNode);
                        window.pitchNode.connect(window.audioCtx.destination);

                        art.audioEncoded = true;

                        const pitchParam = window.pitchNode.parameters.get('pitch');
                        if (pitchParam) pitchParam.value = 0;

                    } catch (e) {
                        console.error("Audio Routing Failed", e);
                    }
                };

                const startInteraction = () => {
                    hasInteracted.value = true;
                    initAudioContext().then(() => {
                        if (art) {
                            art.play().catch(() => { });
                            connectAudioNode();
                        }
                    });

                    if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(() => { });
                    nextTick(() => generateQR());
                };

                const generateQR = () => {
                    const container = document.getElementById('qrcode');
                    if (container && currentNetwork.value.ip !== '...') {
                        container.innerHTML = '';
                        const url = `http://${currentNetwork.value.ip}:${systemPort.value}/controller.html`;
                        new QRCode(container, {
                            text: url,
                            width: 220,
                            height: 220,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.L
                        });
                    }
                };

                const startHeartbeat = () => {
                    if (tickInterval) clearInterval(tickInterval);
                    tickInterval = setInterval(() => {
                        if (art && art.video) {
                            syncKaraokeAudio(); // Keep karaoke audio in sync
                            socket.emit('player_tick', {
                                playing: !art.video.paused,
                                currentTime: art.currentTime,
                                duration: art.duration,
                                volume: art.volume,
                                pitch: window.pitchNode && window.pitchNode.parameters.get('pitch') ? window.pitchNode.parameters.get('pitch').value : 0,
                                vocalRemoval: isVocalRemovalActive
                            });
                        }
                    }, 1000);
                };

                const initPlayer = (url) => {
                    if (art) { art.destroy(false); art = null; }
                    art = new Artplayer({
                        container: '#artplayer',
                        url: url,
                        autoplay: true,
                        volume: 0.8,
                        isLive: false,
                        autoSize: true,
                        fullscreen: true,
                        theme: '#ffffff',
                    });

                    art.on('video:ended', () => socket.emit('next_song'));
                    art.on('ready', () => {
                        if (hasInteracted.value) {
                            if (window.audioCtx && window.audioCtx.state === 'suspended') window.audioCtx.resume();
                            art.play().catch(() => { });
                            connectAudioNode();
                            // Reset vocal removal on new song
                            isVocalRemovalActive = false;
                            if (karaokeAudio) {
                                karaokeAudio.pause();
                                karaokeAudio = null;
                            }
                            art.video.muted = false;
                        }

                        // Add event listeners for karaoke audio sync
                        art.video.addEventListener('play', () => syncKaraokeAudio());
                        art.video.addEventListener('pause', () => syncKaraokeAudio());
                        art.video.addEventListener('seeked', () => syncKaraokeAudio());

                        startHeartbeat();
                        socket.emit('player_tick', { playing: true, currentTime: 0, duration: art.duration, volume: 0.8, pitch: 0, vocalRemoval: false });
                    });
                };

                // Remove existing references to ensure clean setup
                socket.on('system_info', (info) => {
                    networks.value = info.networks;
                    systemSSID.value = info.ssid;
                    systemPort.value = info.port;
                    if (!isPlayingVideo.value && hasInteracted.value) {
                        nextTick(() => generateQR());
                    }
                });

                socket.on('sync_state', (state) => {
                    const newSong = state.currentPlaying;
                    const oldSong = currentSong.value;
                    currentSong.value = newSong;

                    if (newSong && newSong.status === 'ready') {
                        const isSameSong = oldSong && oldSong.id === newSong.id;
                        const wasReady = oldSong && oldSong.status === 'ready';

                        if (!isSameSong || !wasReady || !art) {
                            initPlayer(newSong.src);
                            showInfo.value = true;
                            setTimeout(() => showInfo.value = false, 8000);
                        }

                        // Initialize karaoke audio if available
                        if (newSong.karaokeReady && newSong.karaokeSrc) {
                            if (!karaokeAudio || karaokeAudio.src !== window.location.origin + newSong.karaokeSrc) {
                                initKaraokeAudio(newSong.karaokeSrc);
                            }
                        }
                    } else if (!newSong) {
                        if (art) { art.destroy(); art = null; }
                        if (tickInterval) clearInterval(tickInterval);
                        if (karaokeAudio) { karaokeAudio.pause(); karaokeAudio = null; }
                        if (hasInteracted.value) nextTick(() => generateQR());
                    }
                });

                socket.on('update_progress', ({ id, progress }) => {
                    if (currentSong.value && currentSong.value.id === id) currentSong.value.progress = progress;
                });

                socket.on('exec_control', (action) => {
                    if (!art) return;
                    switch (action.type) {
                        case 'toggle':
                            art.toggle();
                            // Use small delay to let video state update before syncing karaoke
                            setTimeout(() => syncKaraokeAudio(), 50);
                            break;
                        case 'seek':
                            art.currentTime = action.value;
                            if (karaokeAudio && isVocalRemovalActive) karaokeAudio.currentTime = action.value;
                            art.notice.show = `${formatTime(action.value)}`;
                            break;
                        case 'volume': art.volume = action.value; art.notice.show = `VOL ${Math.round(action.value * 100)}`; break;
                        case 'seek_fwd':
                            art.forward = 5;
                            setTimeout(() => syncKaraokeAudio(), 50);
                            break;
                        case 'seek_rew':
                            art.backward = 5;
                            setTimeout(() => syncKaraokeAudio(), 50);
                            break;
                        case 'replay':
                            art.currentTime = 0;
                            if (karaokeAudio && isVocalRemovalActive) karaokeAudio.currentTime = 0;
                            art.play();
                            break;
                        case 'reload': location.reload(); break;
                        case 'pitch':
                            if (window.pitchNode) {
                                const param = window.pitchNode.parameters.get('pitch');
                                if (param) param.setValueAtTime(action.value, window.audioCtx.currentTime);
                                art.notice.show = `KEY ${action.value > 0 ? '+' : ''}${action.value}`;
                            }
                            break;
                        case 'vocal_removal':
                            if (currentSong.value && currentSong.value.karaokeReady) {
                                // Ensure karaoke audio is initialized before toggling
                                if (!karaokeAudio && currentSong.value.karaokeSrc) {
                                    initKaraokeAudio(currentSong.value.karaokeSrc);
                                }
                                toggleVocalRemoval(action.value);
                                art.notice.show = `VOCAL ${action.value ? 'OFF' : 'ON'}`;
                            } else {
                                art.notice.show = 'Karaoke not ready';
                            }
                            break;
                    }
                    setTimeout(() => {
                        let currentPitch = 0;
                        if (window.pitchNode) {
                            const p = window.pitchNode.parameters.get('pitch');
                            if (p) currentPitch = p.value;
                        }

                        if (art) socket.emit('player_tick', {
                            playing: !art.video.paused,
                            currentTime: art.currentTime,
                            duration: art.duration,
                            volume: art.volume,
                            pitch: currentPitch,
                            vocalRemoval: isVocalRemovalActive
                        });
                    }, 50);
                });

                const formatTime = (seconds) => {
                    const m = Math.floor(seconds / 60);
                    const s = Math.floor(seconds % 60);
                    return `${m}:${s.toString().padStart(2, '0')}`;
                };

                return { currentSong, isPlayingVideo, showInfo, hasInteracted, startInteraction, networks, currentNetwork, currentNetIndex, nextNetwork, systemSSID, systemPort };
            }
        }).mount('#app');
    </script>
    <style>
        .song-info-enter-active,
        .song-info-leave-active {
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .song-info-enter-from,
        .song-info-leave-to {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            filter: blur(10px);
        }

        .song-info-enter-to,
        .song-info-leave-from {
            opacity: 1;
            transform: translateY(0) scale(1);
            filter: blur(0);
        }
    </style>
</body>

</html>