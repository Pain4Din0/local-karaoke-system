<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Player</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Noto+Sans+JP:wght@400;700&family=Noto+Sans+SC:wght@400;700&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/artplayer/dist/artplayer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/remixicon@3.5.0/fonts/remixicon.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans SC', 'Noto Sans JP', sans-serif;
        }

        body.hide-cursor {
            cursor: none;
        }

        .fade-enter-active,
        .fade-leave-active {
            transition: opacity 0.5s ease;
        }

        .fade-enter-from,
        .fade-leave-to {
            opacity: 0;
        }
    </style>
</head>

<body class="bg-black text-white overflow-hidden h-screen w-screen selection:bg-white selection:text-black">
    <div id="app" class="relative w-full h-full">

        <div v-if="!hasInteracted" @click="startInteraction"
            class="absolute inset-0 z-50 bg-black flex flex-col items-center justify-center cursor-pointer">
            <div class="border border-white/20 hover:bg-white/10 transition-colors rounded-full p-6 mb-4 animate-pulse">
                <i class="ri-hand-coin-line text-4xl"></i>
            </div>
            <p class="text-xs tracking-[0.2em] text-gray-500 uppercase">Click to Initialize System</p>
        </div>

        <div id="artplayer" class="w-full h-full absolute top-0 left-0 z-10"></div>

        <div v-if="!isPlayingVideo && hasInteracted"
            class="absolute inset-0 flex items-center justify-center z-20 bg-black">
            <div class="w-full max-w-5xl px-8">

                <div v-if="currentSong && currentSong.status !== 'ready'"
                    class="space-y-6 text-center max-w-2xl mx-auto">
                    <div class="flex justify-between items-end mb-2">
                        <span class="text-xs font-mono text-gray-400">DOWNLOADING</span>
                        <span class="text-xs font-mono text-white">{{ Math.floor(currentSong.progress || 0) }}%</span>
                    </div>
                    <div class="w-full h-[1px] bg-gray-800 overflow-hidden">
                        <div class="h-full bg-white transition-all duration-300 ease-out"
                            :style="{width: (currentSong.progress || 0) + '%'}"></div>
                    </div>
                    <p class="text-3xl font-light text-white truncate mt-8 opacity-80">{{ currentSong.title }}</p>
                </div>

                <div v-else class="flex flex-col md:flex-row items-center justify-center gap-12 select-none">

                    <div @click="nextNetwork" class="relative group cursor-pointer"
                        title="Click to switch network interface">
                        <div
                            class="bg-white p-4 rounded-xl shadow-2xl transition-transform group-hover:scale-105 duration-300 border-4 border-transparent group-hover:border-zinc-700">
                            <div id="qrcode" class="w-[220px] h-[220px]"></div>
                        </div>

                        <div v-if="networks.length > 1" class="absolute -bottom-10 left-0 w-full text-center">
                            <p
                                class="text-[10px] uppercase tracking-widest text-zinc-500 group-hover:text-white transition-colors bg-black/50 py-1 rounded">
                                <i class="ri-arrow-left-right-line align-middle mr-1"></i> Click QR to Switch
                            </p>
                            <div class="flex justify-center gap-1.5 mt-2">
                                <div v-for="(net, idx) in networks" :key="idx"
                                    class="w-1.5 h-1.5 rounded-full transition-all"
                                    :class="idx === currentNetIndex ? 'bg-white' : 'bg-zinc-800'"></div>
                            </div>
                        </div>
                    </div>

                    <div class="text-left space-y-8 min-w-[300px]">
                        <div>
                            <p class="text-xs text-zinc-500 font-mono tracking-widest uppercase mb-2">Current Network
                            </p>
                            <div
                                class="inline-flex items-center gap-2 border border-zinc-800 px-3 py-1 rounded-full bg-zinc-900">
                                <i class="ri-router-line text-zinc-400 text-sm"></i>
                                <span class="text-sm font-medium text-zinc-300">{{ currentNetwork.name }}</span>
                            </div>
                        </div>

                        <div>
                            <p class="text-xs text-zinc-500 font-mono tracking-widest uppercase mb-2">Connect via URL
                            </p>
                            <p class="text-3xl font-light text-white tracking-tight break-all cursor-text select-text">
                                <span class="text-zinc-600">http://</span>{{ currentNetwork.ip }}<span
                                    class="text-zinc-600">:{{ systemPort }}</span>
                            </p>
                        </div>

                        <div class="pt-4 border-t border-zinc-900">
                            <div class="flex items-center gap-2 text-zinc-500">
                                <i class="ri-wifi-line"></i>
                                <span class="text-xs uppercase tracking-wider">Host SSID: {{ systemSSID }}</span>
                            </div>
                        </div>
                    </div>
                </div>

            </div>
        </div>

        <Transition name="song-info">
            <div v-if="isPlayingVideo && showInfo" class="absolute top-8 left-8 max-w-2xl z-30 pointer-events-none">
                <div class="bg-black/40 backdrop-blur-md rounded-2xl p-6 border border-white/10 shadow-2xl">
                    <h1 class="text-4xl font-bold leading-tight text-white mb-3 line-clamp-2 drop-shadow-sm">{{
                        currentSong.title }}</h1>
                    <div class="flex items-center gap-3">
                        <span
                            class="bg-white/20 px-2 py-0.5 text-[10px] font-bold rounded uppercase tracking-wider text-white/90">Requested
                            By</span>
                        <span class="text-lg font-light text-gray-200">{{ currentSong.requester }}</span>
                    </div>
                </div>
            </div>
        </Transition>
    </div>

    <script>
        const { createApp, ref, computed, nextTick, watch } = Vue;
        const socket = io();
        let art = null;
        let tickInterval = null;

        createApp({
            setup() {
                const currentSong = ref(null);
                const showInfo = ref(false);
                const hasInteracted = ref(false);
                const systemInfo = ref({ ssid: 'Loading...', url: 'Loading...', ip: '' });
                const isPlayingVideo = computed(() => currentSong.value && currentSong.value.status === 'ready');

                const networks = ref([{ name: 'Loading', ip: '...' }]);
                const currentNetIndex = ref(0);
                const systemSSID = ref('...');
                const systemPort = ref('8080');

                const currentNetwork = computed(() => networks.value[currentNetIndex.value] || networks.value[0]);

                watch(isPlayingVideo, (playing) => {
                    if (playing) {
                        document.body.classList.add('hide-cursor');
                    } else {
                        document.body.classList.remove('hide-cursor');
                    }
                });

                const nextNetwork = () => {
                    if (networks.value.length <= 1) return;
                    currentNetIndex.value = (currentNetIndex.value + 1) % networks.value.length;
                    nextTick(() => generateQR());
                };

                // --- Dual Audio Crossfade Architecture ---
                // Both original and karaoke audio play simultaneously, synced to video
                // Switching is instant via gain crossfade - no loading delay
                // Audio chain: [OriginalAudio → OriginalGain] + [KaraokeAudio → KaraokeGain] → VolumeGain → LoudnessGain → PitchNode → Destination

                let originalAudio = null;
                let karaokeAudio = null;
                let originalSourceNode = null;
                let karaokeSourceNode = null;
                let originalGainNode = null;
                let karaokeGainNode = null;
                let volumeGainNode = null;
                let loudnessGainNode = null;
                let isVocalRemovalActive = false;
                let isLoudnessNormEnabled = true;
                let currentLoudnessGain = 0;
                let currentVolume = 0.8;
                const CROSSFADE_TIME = 0.1; // 100ms crossfade

                const dbToLinear = (db) => Math.pow(10, db / 20);

                const initAudioContext = async () => {
                    if (window.audioCtx) return;
                    try {
                        window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                        await window.audioCtx.audioWorklet.addModule('pitch-processor.js');
                        window.pitchNode = new AudioWorkletNode(window.audioCtx, 'pitch-processor');

                        // Create gain nodes for crossfade and processing
                        originalGainNode = window.audioCtx.createGain();
                        karaokeGainNode = window.audioCtx.createGain();
                        volumeGainNode = window.audioCtx.createGain();
                        loudnessGainNode = window.audioCtx.createGain();

                        originalGainNode.gain.value = 1.0; // Original on
                        karaokeGainNode.gain.value = 0.0;  // Karaoke off
                        volumeGainNode.gain.value = currentVolume;
                        loudnessGainNode.gain.value = 1.0;

                        // Connect processing chain (sources connect later)
                        // Original and Karaoke both go through: their gain → volume → loudness → pitch → destination
                        originalGainNode.connect(volumeGainNode);
                        karaokeGainNode.connect(volumeGainNode);
                        volumeGainNode.connect(loudnessGainNode);
                        loudnessGainNode.connect(window.pitchNode);
                        window.pitchNode.connect(window.audioCtx.destination);
                    } catch (e) {
                        console.error("AudioContext Init Failed", e);
                    }
                };

                // Create and connect an audio element
                const createAudioElement = (src, isKaraoke) => {
                    const audio = new Audio();
                    audio.crossOrigin = 'anonymous';
                    audio.preload = 'auto';
                    audio.src = src;
                    audio.load();
                    return audio;
                };

                // Connect audio element to Web Audio
                const connectAudioSource = (audio, gainNode) => {
                    if (!audio || !window.audioCtx || !gainNode) return null;
                    try {
                        const sourceNode = window.audioCtx.createMediaElementSource(audio);
                        sourceNode.connect(gainNode);
                        return sourceNode;
                    } catch (e) {
                        console.error('[Audio] Source connection failed:', e);
                        return null;
                    }
                };

                // Initialize both audio tracks for a song
                const initDualAudio = (originalSrc, karaokeSrc, loudnessGain) => {
                    // Cleanup previous audio elements completely
                    if (originalAudio) { originalAudio.pause(); originalAudio.src = ''; }
                    if (karaokeAudio) { karaokeAudio.pause(); karaokeAudio.src = ''; }
                    if (originalSourceNode) { try { originalSourceNode.disconnect(); } catch (e) { } }
                    if (karaokeSourceNode) { try { karaokeSourceNode.disconnect(); } catch (e) { } }

                    // Must null out all references so new ones can be created
                    originalAudio = null;
                    karaokeAudio = null;
                    originalSourceNode = null;
                    karaokeSourceNode = null;

                    currentLoudnessGain = loudnessGain || 0;
                    isVocalRemovalActive = false;

                    // Reset gains
                    if (originalGainNode) originalGainNode.gain.value = 1.0;
                    if (karaokeGainNode) karaokeGainNode.gain.value = 0.0;

                    // Create original audio
                    originalAudio = createAudioElement(originalSrc, false);
                    originalAudio.addEventListener('canplaythrough', () => {
                        if (!originalSourceNode) {
                            originalSourceNode = connectAudioSource(originalAudio, originalGainNode);
                        }
                        updateLoudnessGain();
                        updateVolume();
                        if (art && !art.video.paused) {
                            originalAudio.currentTime = art.currentTime;
                            originalAudio.play().catch(() => { });
                        }
                    }, { once: true });

                    // Create karaoke audio if available (pre-load for seamless switch)
                    if (karaokeSrc) {
                        karaokeAudio = createAudioElement(karaokeSrc, true);
                        karaokeAudio.addEventListener('canplaythrough', () => {
                            if (!karaokeSourceNode) {
                                karaokeSourceNode = connectAudioSource(karaokeAudio, karaokeGainNode);
                            }
                            // Sync time but don't play yet (gain is 0)
                            if (art) karaokeAudio.currentTime = art.currentTime;
                            // Keep synced and playing (muted via gain)
                            karaokeAudio.play().catch(() => { });
                        }, { once: true });
                    }
                };

                // Add karaoke track after processing completes
                const addKaraokeTrack = (karaokeSrc) => {
                    if (karaokeAudio) return; // Already exists
                    if (!karaokeSrc) return;

                    karaokeAudio = createAudioElement(karaokeSrc, true);
                    karaokeAudio.addEventListener('canplaythrough', () => {
                        if (!karaokeSourceNode) {
                            karaokeSourceNode = connectAudioSource(karaokeAudio, karaokeGainNode);
                        }
                        // Sync to current position and play (muted via gain)
                        if (art) karaokeAudio.currentTime = art.currentTime;
                        if (originalAudio && !originalAudio.paused) {
                            karaokeAudio.play().catch(() => { });
                        }
                    }, { once: true });
                };

                const updateLoudnessGain = () => {
                    if (!loudnessGainNode || !window.audioCtx) return;
                    const linearGain = isLoudnessNormEnabled ? dbToLinear(currentLoudnessGain) : 1.0;
                    loudnessGainNode.gain.setValueAtTime(linearGain, window.audioCtx.currentTime);
                };

                const updateVolume = () => {
                    if (!volumeGainNode || !window.audioCtx) return;
                    volumeGainNode.gain.setValueAtTime(currentVolume, window.audioCtx.currentTime);
                };

                const toggleLoudnessNorm = (enabled) => {
                    isLoudnessNormEnabled = enabled;
                    updateLoudnessGain();
                };

                // Seamless crossfade switch between original and karaoke
                const switchAudioSource = (karaokeSrc, karaokeMode) => {
                    if (!window.audioCtx || !originalGainNode || !karaokeGainNode) return;

                    isVocalRemovalActive = karaokeMode;
                    const now = window.audioCtx.currentTime;

                    // Ensure karaoke track is loaded
                    if (karaokeMode && !karaokeAudio && karaokeSrc) {
                        addKaraokeTrack(karaokeSrc);
                    }

                    // Crossfade gains
                    if (karaokeMode && karaokeAudio) {
                        // Sync karaoke time precisely before crossfade
                        if (originalAudio) {
                            karaokeAudio.currentTime = originalAudio.currentTime;
                        }
                        if (karaokeAudio.paused) karaokeAudio.play().catch(() => { });

                        // Fade out original, fade in karaoke
                        originalGainNode.gain.setValueAtTime(originalGainNode.gain.value, now);
                        originalGainNode.gain.linearRampToValueAtTime(0.0, now + CROSSFADE_TIME);
                        karaokeGainNode.gain.setValueAtTime(karaokeGainNode.gain.value, now);
                        karaokeGainNode.gain.linearRampToValueAtTime(1.0, now + CROSSFADE_TIME);
                    } else {
                        // Fade in original, fade out karaoke
                        originalGainNode.gain.setValueAtTime(originalGainNode.gain.value, now);
                        originalGainNode.gain.linearRampToValueAtTime(1.0, now + CROSSFADE_TIME);
                        karaokeGainNode.gain.setValueAtTime(karaokeGainNode.gain.value, now);
                        karaokeGainNode.gain.linearRampToValueAtTime(0.0, now + CROSSFADE_TIME);
                    }
                };

                // Sync both audio elements with video - tighter threshold for precision
                // Using 20ms threshold (0.02s) for imperceptible sync
                const SYNC_THRESHOLD = 0.02;

                const syncAudio = () => {
                    if (!art || !art.video) return;
                    const videoTime = art.currentTime;
                    const videoPaused = art.video.paused;

                    // Sync original audio to video
                    if (originalAudio) {
                        if (Math.abs(originalAudio.currentTime - videoTime) > SYNC_THRESHOLD) {
                            originalAudio.currentTime = videoTime;
                        }
                        if (!videoPaused && originalAudio.paused) {
                            originalAudio.play().catch(() => { });
                        } else if (videoPaused && !originalAudio.paused) {
                            originalAudio.pause();
                        }
                    }

                    // Sync karaoke to original audio (more precise than syncing to video)
                    if (karaokeAudio && originalAudio) {
                        if (Math.abs(karaokeAudio.currentTime - originalAudio.currentTime) > SYNC_THRESHOLD) {
                            karaokeAudio.currentTime = originalAudio.currentTime;
                        }
                        if (!originalAudio.paused && karaokeAudio.paused) {
                            karaokeAudio.play().catch(() => { });
                        } else if (originalAudio.paused && !karaokeAudio.paused) {
                            karaokeAudio.pause();
                        }
                    }
                };

                const startInteraction = () => {

                    hasInteracted.value = true;
                    initAudioContext().then(() => {
                        if (art) {
                            art.play().catch(() => { });
                            connectAudioNode();
                        }
                    });

                    if (document.documentElement.requestFullscreen) document.documentElement.requestFullscreen().catch(() => { });
                    nextTick(() => generateQR());
                };

                const generateQR = () => {
                    const container = document.getElementById('qrcode');
                    if (container && currentNetwork.value.ip !== '...') {
                        container.innerHTML = '';
                        const url = `http://${currentNetwork.value.ip}:${systemPort.value}/controller.html`;
                        new QRCode(container, {
                            text: url,
                            width: 220,
                            height: 220,
                            colorDark: "#000000",
                            colorLight: "#ffffff",
                            correctLevel: QRCode.CorrectLevel.L
                        });
                    }
                };

                const startHeartbeat = () => {
                    if (tickInterval) clearInterval(tickInterval);
                    tickInterval = setInterval(() => {
                        if (art && art.video) {
                            syncAudio(); // Keep audio in sync with video
                            socket.emit('player_tick', {
                                playing: !art.video.paused,
                                currentTime: art.currentTime,
                                duration: art.duration,
                                volume: currentVolume,
                                pitch: window.pitchNode && window.pitchNode.parameters.get('pitch') ? window.pitchNode.parameters.get('pitch').value : 0,
                                vocalRemoval: isVocalRemovalActive,
                                loudnessNorm: isLoudnessNormEnabled
                            });
                        }
                    }, 200); // 200ms interval for precise sync
                };

                const initPlayer = (videoUrl, audioSrc, loudnessGain) => {
                    if (art) { art.destroy(false); art = null; }
                    art = new Artplayer({
                        container: '#artplayer',
                        url: videoUrl,
                        autoplay: true,
                        volume: 0.8, // Volume controlled via Web Audio
                        muted: true, // Video always muted, audio from separate element
                        isLive: false,
                        autoSize: true,
                        fullscreen: true,
                        theme: '#ffffff',
                    });

                    art.on('video:ended', () => socket.emit('next_song'));
                    art.on('ready', () => {
                        if (hasInteracted.value) {
                            if (window.audioCtx && window.audioCtx.state === 'suspended') window.audioCtx.resume();
                            art.play().catch(() => { });
                            art.video.muted = true; // Ensure video stays muted

                            // Initialize dual audio for seamless crossfade
                            if (audioSrc) {
                                const karaokeSrc = currentSong.value?.karaokeSrc || null;
                                initDualAudio(audioSrc, karaokeSrc, loudnessGain);
                            }

                            // Reset vocal removal on new song
                            isVocalRemovalActive = false;
                        }

                        // Add event listeners for audio sync
                        art.video.addEventListener('play', () => syncAudio());
                        art.video.addEventListener('pause', () => syncAudio());
                        art.video.addEventListener('seeked', () => syncAudio());

                        startHeartbeat();
                        socket.emit('player_tick', { playing: true, currentTime: 0, duration: art.duration, volume: currentVolume, pitch: 0, vocalRemoval: false, loudnessNorm: isLoudnessNormEnabled });
                    });
                };

                // Remove existing references to ensure clean setup
                socket.on('system_info', (info) => {
                    networks.value = info.networks;
                    systemSSID.value = info.ssid;
                    systemPort.value = info.port;
                    if (!isPlayingVideo.value && hasInteracted.value) {
                        nextTick(() => generateQR());
                    }
                });

                socket.on('sync_state', (state) => {
                    const newSong = state.currentPlaying;
                    const oldSong = currentSong.value;
                    currentSong.value = newSong;

                    if (newSong && newSong.status === 'ready') {
                        const isSameSong = oldSong && oldSong.id === newSong.id;
                        const wasReady = oldSong && oldSong.status === 'ready';

                        if (!isSameSong || !wasReady || !art) {
                            // Initialize with separate video and audio sources
                            initPlayer(newSong.src, newSong.audioSrc, newSong.loudnessGain);
                            showInfo.value = true;
                            setTimeout(() => showInfo.value = false, 8000);
                        } else if (isSameSong && newSong.karaokeReady && !karaokeAudio && newSong.karaokeSrc) {
                            // Karaoke just became ready - pre-load it for seamless switching
                            addKaraokeTrack(newSong.karaokeSrc);
                        }
                    } else if (!newSong) {
                        if (art) { art.destroy(); art = null; }
                        if (tickInterval) clearInterval(tickInterval);
                        if (originalAudio) { originalAudio.pause(); originalAudio.src = ''; }
                        if (karaokeAudio) { karaokeAudio.pause(); karaokeAudio.src = ''; }
                        if (hasInteracted.value) nextTick(() => generateQR());
                    }
                });

                socket.on('update_progress', ({ id, progress }) => {
                    if (currentSong.value && currentSong.value.id === id) currentSong.value.progress = progress;
                });

                socket.on('exec_control', (action) => {
                    if (!art) return;
                    switch (action.type) {
                        case 'toggle':
                            art.toggle();
                            setTimeout(() => syncAudio(), 50);
                            break;
                        case 'seek':
                            art.currentTime = action.value;
                            if (originalAudio) originalAudio.currentTime = action.value;
                            if (karaokeAudio) karaokeAudio.currentTime = action.value;
                            art.notice.show = `${formatTime(action.value)}`;
                            break;
                        case 'volume':
                            currentVolume = action.value;
                            updateVolume();
                            art.notice.show = `VOL ${Math.round(action.value * 100)}`;
                            break;
                        case 'seek_fwd':
                            art.forward = 5;
                            setTimeout(() => syncAudio(), 50);
                            break;
                        case 'seek_rew':
                            art.backward = 5;
                            setTimeout(() => syncAudio(), 50);
                            break;
                        case 'replay':
                            art.currentTime = 0;
                            if (originalAudio) originalAudio.currentTime = 0;
                            if (karaokeAudio) karaokeAudio.currentTime = 0;
                            art.play();
                            syncAudio();
                            break;
                        case 'reload': location.reload(); break;
                        case 'pitch':
                            if (window.pitchNode) {
                                const param = window.pitchNode.parameters.get('pitch');
                                if (param) param.setValueAtTime(action.value, window.audioCtx.currentTime);
                                art.notice.show = `KEY ${action.value > 0 ? '+' : ''}${action.value}`;
                            }
                            break;
                        case 'vocal_removal':
                            if (currentSong.value && currentSong.value.karaokeReady && currentSong.value.karaokeSrc) {
                                switchAudioSource(currentSong.value.karaokeSrc, action.value);
                                art.notice.show = `VOCAL ${action.value ? 'OFF' : 'ON'}`;
                            } else if (action.value) {
                                art.notice.show = 'Karaoke not ready';
                            } else {
                                // Switching back to original audio
                                if (currentSong.value && currentSong.value.audioSrc) {
                                    switchAudioSource(null, false);
                                    art.notice.show = 'VOCAL ON';
                                }
                            }
                            break;
                        case 'loudness_norm':
                            toggleLoudnessNorm(action.value);
                            art.notice.show = `LOUDNESS ${action.value ? 'ON' : 'OFF'}`;
                            break;
                    }
                    setTimeout(() => {
                        let currentPitch = 0;
                        if (window.pitchNode) {
                            const p = window.pitchNode.parameters.get('pitch');
                            if (p) currentPitch = p.value;
                        }

                        if (art) socket.emit('player_tick', {
                            playing: !art.video.paused,
                            currentTime: art.currentTime,
                            duration: art.duration,
                            volume: currentVolume,
                            pitch: currentPitch,
                            vocalRemoval: isVocalRemovalActive,
                            loudnessNorm: isLoudnessNormEnabled
                        });
                    }, 50);
                });

                const formatTime = (seconds) => {
                    const m = Math.floor(seconds / 60);
                    const s = Math.floor(seconds % 60);
                    return `${m}:${s.toString().padStart(2, '0')}`;
                };

                return { currentSong, isPlayingVideo, showInfo, hasInteracted, startInteraction, networks, currentNetwork, currentNetIndex, nextNetwork, systemSSID, systemPort };
            }
        }).mount('#app');
    </script>
    <style>
        .song-info-enter-active,
        .song-info-leave-active {
            transition: all 0.8s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .song-info-enter-from,
        .song-info-leave-to {
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            filter: blur(10px);
        }

        .song-info-enter-to,
        .song-info-leave-from {
            opacity: 1;
            transform: translateY(0) scale(1);
            filter: blur(0);
        }
    </style>
</body>

</html>